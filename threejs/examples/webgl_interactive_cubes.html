<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - interactive cubes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <script src="../build/three.js"></script>

    <script src="js/libs/stats.min.js"></script>

    <script>
        var container, stats;
        var camera, scene, raycaster, renderer;
        // 定义鼠标点击坐标
        var mouse = new THREE.Vector2(),
            INTERSECTED;
        var radius = 100,
            theta = 0;

        init();
        animate();
        // 初始化创建

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);
            // 定义相机
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
            // 定义场景
            scene = new THREE.Scene();
            // 定义灯光
            var light = new THREE.AmbientLight(0xf0f0f0, 0.8);
            light.position.set(0, 0, 0).normalize();
            // light.position.set(1, 1, 1);
            scene.add(light);
            // 定义模型结构
            var geometry = new THREE.BoxBufferGeometry(20, 20, 20);
            // 定义不同材质
            for (var i = 0; i < 10000; i++) {
                // 创建不同模型
                var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
                    color: Math.random() * 0xffffff
                }));
                // 模型的位置
                object.position.x = Math.random() * 2000 - 400;
                object.position.y = Math.random() * 2000 - 400;
                object.position.z = Math.random() * 2000 - 400;
                // 模型的旋转
                object.rotation.x = Math.random() * 2 * Math.PI;
                object.rotation.y = Math.random() * 2 * Math.PI;
                object.rotation.z = Math.random() * 2 * Math.PI;
                // 模型的缩放
                object.scale.x = Math.random() + 0.5;
                object.scale.y = Math.random() + 0.5;
                object.scale.z = Math.random() + 0.5;
                // 将模型添加到场景中
                scene.add(object);

            }
            // 创建光线投射器实例
            // Raycaster( origin, direction, near, far )
            // origin — 光线投射的起点向量。
            // direction — 光线投射的方向向量，应该是被归一化的。
            // near — 投射近点，用来限定返回比near要远的结果。near不能为负数。缺省为0。
            // far — 投射远点，用来限定返回比far要近的结果。far不能比near要小。缺省为无穷大。
            // 属性：
            // linePrecision:当线与对象相交时，raycaster的精度系数。
            // ray:用于光线投射的射线
            // near：光纤投射器的近点因子，这个值指示基于这个距离哪些对象可以被舍弃。这个值不能是负的，且应该小于far属性。
            // far:光线投射器的远点因子，这个值指示基于这个距离哪些对象可以被舍弃。这个值不能是负的，且应该大于near属性。
            raycaster = new THREE.Raycaster();

            // 创建渲染器
            renderer = new THREE.WebGLRenderer();
            // 设置清除的颜色和透明度。
            renderer.setClearColor(0xf0f0f0, 0.8);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            // 定义渲染器是否需要对对象排序。默认为 true。
            renderer.sortObjects = false;
            container.appendChild(renderer.domElement);
            // 定义监视器
            stats = new Stats();

            container.appendChild(stats.dom);

            document.addEventListener('mousemove', onDocumentMouseMove, false);

            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize() {
            // 相机视垂体宽高比
            camera.aspect = window.innerWidth / window.innerHeight;
            // 更新相机投影矩阵，必须在参数发生变化后调用。
            camera.updateProjectionMatrix();
            // 渲染器重新设置大小
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            // 取消默认事件
            event.preventDefault();
            // 中心点为0,左负下负上正右正
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }


        // 实时渲染
        function animate() {

            requestAnimationFrame(animate);
            // 模型移动
            render();
            // 监视器更新
            stats.update();
        }
        var flag = true;

        function render() {

            theta += 0.1;
            // THREE.Math.degToRad(degrees)将度数转化为弧度
            // THREE.Math.radToDeg ( radians )将弧度转化为度数
            camera.position.x = radius * Math.sin(THREE.Math.degToRad(theta));
            camera.position.y = radius * Math.sin(THREE.Math.degToRad(theta));
            camera.position.z = radius * Math.cos(THREE.Math.degToRad(theta));
            camera.lookAt(scene.position);

            camera.updateMatrixWorld();

            // find intersections
            // 更新射线通过镜头和鼠标的位置
            raycaster.setFromCamera(mouse, camera);
            // 计算射线与对象相交 
            // 检测射线与对象所有交点是否带有后代，交叉点按距离排列，最接近的为第一个
            var intersects = raycaster.intersectObjects(scene.children);
            // 如果存在光线与对象相交
            if (intersects.length > 0) {
                // INTERSECTED为当前鼠标与正方形相交的对象
                if (INTERSECTED != intersects[0].object) {
                    // 将该对象的发射性颜色设置为
                    if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

                    INTERSECTED = intersects[0].object;
                    INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                    INTERSECTED.material.emissive.setHex(0x00ff00);

                }

            } else {

                if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

                INTERSECTED = null;

            }

            renderer.render(scene, camera);

        }
    </script>

</body>

</html>